import{_ as s,c as n,o as a,S as l}from"./chunks/framework.3EKbrk2Y.js";const m=JSON.parse('{"title":"模块化开发：AMD、CMD、UMD、CommonJS和EsModule的浅谈","description":"","frontmatter":{"title":"模块化开发：AMD、CMD、UMD、CommonJS和EsModule的浅谈","date":"2023-12-22T09:48:00.000Z"},"headers":[],"relativePath":"frontend/js-module-types/index.md","filePath":"frontend/js-module-types/index.md"}'),p={name:"frontend/js-module-types/index.md"},e=l(`<p>模块化是目前开发绕不开的话题，很多语言都有类似的机制，但最初作为脚本目的的 JavaScript 却没有这样的机制。这也导致后来社区群起提出很多规范，经过多年争执和混乱，目前使用最广的 是 2 大模块规范：CommonJS 和 EsModule 规范。其中 CommonJS 是 NodeJS 的内置规范，而 EsModule 则是 ECMA 提出的标准规范。本文会简单聊聊以往的模块规范(多数已逐渐淘汰，因此不必太过深入)，然后聊聊当前 2 大模块规范在当前开发中的使用。</p><h2 id="历史规范" tabindex="-1">历史规范 <a class="header-anchor" href="#历史规范" aria-label="Permalink to &quot;历史规范&quot;">​</a></h2><p>在 NodeJS 出现以前，前端的模块化是比较模糊的，大部分是使用全局命名、命名空间、IIFE之类的实现。在 2009 年起，开始出现名为 Server.js 的模块规范，后来为进一步推广到浏览器端，改名 CommonJS。但是，服务器端和浏览器端加载机制是不同的：在服务器端，模块文件都在本地，使用文件系统调用是非常快的，因而一般采用同步加载的方式；在浏览器端，模块文件都在服务器，通过网络加载是不确定具体加载时间的，因而一般采用异步加载的方式。</p><p>围绕着模块加载和执行时机问题，出现几个常见的模块规范：</p><h3 id="amd" tabindex="-1">AMD <a class="header-anchor" href="#amd" aria-label="Permalink to &quot;AMD&quot;">​</a></h3><p><a href="https://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="noreferrer">AMD</a>，即 Async Module Definition(异步模块定义)，适用于浏览器端，<a href="https://requirejs.org/" target="_blank" rel="noreferrer">RequireJS</a> 是其中的实现。主要写法如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#6A737D;">  // 提前定义依赖</span></span>
<span class="line"><span style="color:#6F42C1;">define</span><span style="color:#24292E;">([</span><span style="color:#032F62;">&quot;a&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;b&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;c&quot;</span><span style="color:#24292E;">], </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#E36209;">b</span><span style="color:#24292E;">, </span><span style="color:#E36209;">c</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 即便没使用模块 b 但依然加载</span></span>
<span class="line"><span style="color:#D73A49;"> if</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">   b.</span><span style="color:#6F42C1;">foo</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="cmd" tabindex="-1">CMD <a class="header-anchor" href="#cmd" aria-label="Permalink to &quot;CMD&quot;">​</a></h3><p><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noreferrer">CMD</a>，即 Common Module Definition(公共模块定义)，适用于浏览器端。<a href="https://github.com/seajs/seajs" target="_blank" rel="noreferrer">SeaJS</a> 是其中的实现。主要写法如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#6F42C1;">define</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">require</span><span style="color:#24292E;">, </span><span style="color:#E36209;">exports</span><span style="color:#24292E;">, </span><span style="color:#E36209;">module</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#6A737D;">  // 就近加载</span></span>
<span class="line"><span style="color:#D73A49;">  var</span><span style="color:#24292E;"> module2 </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;./module2&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6A737D;">  //暴露模块</span></span>
<span class="line"><span style="color:#005CC5;">  exports</span><span style="color:#24292E;">.xxx </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="umd" tabindex="-1">UMD <a class="header-anchor" href="#umd" aria-label="Permalink to &quot;UMD&quot;">​</a></h3><p><a href="https://github.com/umdjs/umd" target="_blank" rel="noreferrer">UMD</a>，即 Universal Module Definition(通用模块定义)，适用于浏览器端和服务器端，是一种同时兼容 AMD 和 CommonJS 的模块规范。主要机制如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">root</span><span style="color:#24292E;">, </span><span style="color:#E36209;">factory</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // AMD 规范</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> define </span><span style="color:#D73A49;">===</span><span style="color:#032F62;"> &#39;function&#39;</span><span style="color:#D73A49;"> &amp;&amp;</span><span style="color:#24292E;"> define.amd) {</span></span>
<span class="line"><span style="color:#6F42C1;">    define</span><span style="color:#24292E;">([</span><span style="color:#032F62;">&#39;jquery&#39;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;underscore&#39;</span><span style="color:#24292E;">], factory);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6A737D;">  // CommomJs 规范</span></span>
<span class="line"><span style="color:#D73A49;">  else</span><span style="color:#D73A49;"> if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#005CC5;"> exports</span><span style="color:#D73A49;"> ===</span><span style="color:#032F62;"> &#39;object&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#005CC5;">    module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> factory</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;jquery&#39;</span><span style="color:#24292E;">), </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;underscore&#39;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6A737D;">  // 全局变量</span></span>
<span class="line"><span style="color:#D73A49;">  else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    root.returnExports </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> factory</span><span style="color:#24292E;">(root.jQuery, root._);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">} (</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (){}))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="常用规范" tabindex="-1">常用规范 <a class="header-anchor" href="#常用规范" aria-label="Permalink to &quot;常用规范&quot;">​</a></h2><p>前面提到的几个规范接触范围并不是很广，日常接触最多的还是 CmmonJS 和 EsModule 规范，接下来聊聊这 2 个规范。</p><h3 id="commonjs" tabindex="-1">CommonJS <a class="header-anchor" href="#commonjs" aria-label="Permalink to &quot;CommonJS&quot;">​</a></h3><p>这是 NodeJS 的内置规范，每个模块以文件为基础，每个文件内可使用几个特殊的变量，如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#6A737D;">// require: 特殊变量，引入模块</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> _</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;lodash&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// module: 特殊变量，当前模块信息</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">id</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// exports: 特殊变量，module.exports 的别名，用于导出内容</span></span>
<span class="line"><span style="color:#005CC5;">exports</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">add</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">x</span><span style="color:#24292E;">, </span><span style="color:#E36209;">y</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> y;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>实际上，CommonJS 并没有从语言规范进行入手，只是借助现有语法来实现，对象引用和赋值导出等问题依然是有的。此外，以上代码中的特殊变量来源，可以理解为加载时使用函数进行包裹传入所得，如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> loadModule</span><span style="color:#24292E;">({ </span><span style="color:#E36209;">require</span><span style="color:#24292E;">, </span><span style="color:#E36209;">module</span><span style="color:#24292E;"> }) {</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> exports </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">  // 模块内的代码</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="esmodule" tabindex="-1">EsModule <a class="header-anchor" href="#esmodule" aria-label="Permalink to &quot;EsModule&quot;">​</a></h3><p>这是 Ecma 的标准规范，每个模块也以文件为基础，每个文件内有几个特殊的语法和变量，如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#6A737D;">// import/from 特殊语法 引入变量</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> _ </span><span style="color:#D73A49;">from</span><span style="color:#032F62;"> &#39;lodash&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// export 特殊语法，导出内容</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> add</span><span style="color:#24292E;">(</span><span style="color:#E36209;">x</span><span style="color:#24292E;">, </span><span style="color:#E36209;">y</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> y;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// import 特殊变量，异步导入</span></span>
<span class="line"><span style="color:#D73A49;">async</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> say</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#005CC5;"> x</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> await</span><span style="color:#D73A49;"> import</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;xxx&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  x.</span><span style="color:#6F42C1;">xx</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看出，EsModule 是从语言层面进行入手的，因而带来非常多的好处。例如，导入导出是可以静态分析的，</p><h2 id="使用区别" tabindex="-1">使用区别 <a class="header-anchor" href="#使用区别" aria-label="Permalink to &quot;使用区别&quot;">​</a></h2><p>以上只是简单聊聊，实际内容有很多，对于我们日常使用，主要还是要关注下面这些：</p><h3 id="静态分析" tabindex="-1">静态分析 <a class="header-anchor" href="#静态分析" aria-label="Permalink to &quot;静态分析&quot;">​</a></h3><p>CommonJS 导出不易于静态分析，EsModule 导入易于静态分析，为什么说这么说？主要在于 CommonJS 中 export 的名字是可以变化的，这在编译时无法找到其具体来源，只能在运行时才能确定，如下：</p><p>使用 CommonJS 的情况(如下)，导出名字允许使用变量，这会导致编译时难以分析：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> name </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &#39;add&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 使用的是对象引用，随时都可以改变</span></span>
<span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> { [name]: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>使用 EsModule 的情况(如下)，导出名字不允许使用变量，编译时就可以确定其代码引用关系：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 1</span></span>
<span class="line"><span style="color:#6A737D;">// 使用的是语言语法，没有修改的余地</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> { value }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="导出机制" tabindex="-1">导出机制 <a class="header-anchor" href="#导出机制" aria-label="Permalink to &quot;导出机制&quot;">​</a></h3><p>CommonJS 导出的是变量，EsModule 导出的是关系，理解这点看如下的例子：</p><p>使用 CommonJS 的情况：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#6A737D;">// a.js</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#6F42C1;"> add</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { x </span><span style="color:#D73A49;">+=</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> { x, add }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// b.js</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> a</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;./a.js&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a.x) </span><span style="color:#6A737D;">// 输出 1</span></span>
<span class="line"><span style="color:#24292E;">a.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">()          </span><span style="color:#6A737D;">// 执行 +1</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a.x) </span><span style="color:#6A737D;">// 输出 1。+1 操作无效，导出的 a.x 与内部的 x 无关系</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>使用 EsModule 的情况：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#6A737D;">// a.js</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#6F42C1;"> add</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { x </span><span style="color:#D73A49;">+=</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> { x, add }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// b.js</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">from</span><span style="color:#032F62;"> &#39;./a.js&#39;</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a.x) </span><span style="color:#6A737D;">// 输出 1</span></span>
<span class="line"><span style="color:#24292E;">a.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">()          </span><span style="color:#6A737D;">// 执行 +1</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a.x) </span><span style="color:#6A737D;">// 输出 2。+1 操作有效，导出的 a.x 与内部的 x 存在关系</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="标识解析" tabindex="-1">标识解析 <a class="header-anchor" href="#标识解析" aria-label="Permalink to &quot;标识解析&quot;">​</a></h2><p>当我们导入某个从 npm 下载的模块时，写的是模块标识，但实际上 from 后面的字符串，最终都要能解析到一个具体的绝对路径。如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#6A737D;">// 写起来：</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> lodash </span><span style="color:#D73A49;">from</span><span style="color:#032F62;"> &#39;lodash&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 实际上：</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> xx </span><span style="color:#D73A49;">from</span><span style="color:#032F62;"> &#39;D://project/myproject/node_modules/lodash/index.mjs&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>解析的算法有很多，其中 NodeJS 自带一套解析算法，社区也有其他算法。根据 NodeJs 的解析算法，上面中的 index.mjs 并不是固定的，而是根据你使用的是 import 还是 require 语法，以及 lodash 中 package.json 的某些字段进行判断。主要包含以下步骤：</p><p>先解析项目的 package.json 得到 type 字段，再解析依赖得 package.json 文件(以下字段均指这里的)，按以下步骤进行判断：</p><ol><li>检查是否有 exports 字段，该字段可以分别指定 import 和 require 时的入口文件，如下：</li></ol><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#005CC5;">  &quot;name&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;todo&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#005CC5;">  &quot;exports&quot;</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#005CC5;">    &quot;.&quot;</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#005CC5;">      &quot;import&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;./index.mjs&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#005CC5;">      &quot;require&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;./index.cjs&quot;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="2"><li>如果 type 为 module，有 module 字段则使用该字段，如下：</li></ol><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#005CC5;">  &quot;name&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;todo&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#005CC5;">  &quot;module&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;./dist/index.mjs&quot;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li>使用 main 字段，在 exports 没出现以前，通常作为 CommonJS 类型的入口与 module 字段相配合，如下：</li></ol><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-light vp-code"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#005CC5;">  &quot;name&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;todo&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#005CC5;">  &quot;main&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;./dist/index.js&quot;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="4"><li>降级为 index.js 文件，如果依赖的 package.json 未指定以上任何字段，其结构应是如下：</li></ol><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-light vp-code"><code><span class="line"><span>.</span></span>
<span class="line"><span>├── index.js</span></span>
<span class="line"><span>└── package.json</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此外，还有一些其他的条件导出，例如，在 NodeJS 环境导出一份，在浏览器环境导出另一份，此处暂不做过多介绍，有兴趣的可以自行谷歌。</p><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h2><p>目前，CommonJS 和 EsModule 通常都在打包下包了一层，增加了不少便捷的特性。例如，可以在 EsModule 中引入 CommonJS 模块，背后是打包工具将 CommonJS 转换为 EsModule 类型。以上，暂时写这么多，有空再补充。</p>`,54),o=[e];function r(c,t,i,y,u,d){return a(),n("div",null,o)}const E=s(p,[["render",r]]);export{m as __pageData,E as default};
