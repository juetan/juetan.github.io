import{_ as s,o as n,c as a,W as p}from"./chunks/framework.d6d633f0.js";const u=JSON.parse('{"title":"写一个Vite插件：根据配置加载不同后缀的文件","description":"","frontmatter":{"title":"写一个Vite插件：根据配置加载不同后缀的文件","date":"2023-07-18T11:31:00.000Z"},"headers":[],"relativePath":"frontend/post-vite-loadup.md","filePath":"frontend/post-vite-loadup.md"}'),o={name:"frontend/post-vite-loadup.md"},l=p(`<p>最近在工作中，遇到两个小问题，让我想写个 Vite 插件。一个是不同项目间的微小差异，某个项目在 A 页面加了需求，其他项目又不需要，直接在页面上加判断感觉没必要，毕竟差异只有一丢丢。另一个时，有新功能时，要新增页面但这个页面最近的版本又不上，这就得动代码了。</p><p>偶然下想起 Taro 根据不同后缀打包的文档，于是去翻了下，想着能不能写一个 Vite 插件，根据配置打包不同后缀的文件。例如，配置为 mx，导入 index.vue 文件时，在 load 钩子中先尝试加载同目录下的 index.mx.vue 文件，再加载 index.vue 文件。</p><p>费了一番功夫，总算搞出来了，这里记录下实现思路。</p><h2 id="在-resolveid-中判断" tabindex="-1">在 ResolveId 中判断 <a class="header-anchor" href="#在-resolveid-中判断" aria-label="Permalink to &quot;在 ResolveId 中判断&quot;">​</a></h2><p>最开始想的是，有一个解析模块路径的钩子，先调用其他插件解析完 ID，再判断指定后缀的文件是否存在，存在就返回包含该后缀的文件路径。实现如下：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">plugin</span><span style="color:#24292E;">({ </span><span style="color:#E36209;">extension</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;me&#39;</span><span style="color:#24292E;"> }) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    name: </span><span style="color:#032F62;">&#39;vite:file-extension&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">resolveId</span><span style="color:#24292E;">(</span><span style="color:#E36209;">id</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">extension </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">id.</span><span style="color:#6F42C1;">startsWith</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;/src&#39;</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">resolution</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(id, importer, { skipSelf: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">options });</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">targetPath</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> resolution?.id.</span><span style="color:#6F42C1;">replace</span><span style="color:#24292E;">(</span><span style="color:#032F62;">/</span><span style="color:#22863A;font-weight:bold;">\\.</span><span style="color:#032F62;">(</span><span style="color:#005CC5;">[</span><span style="color:#D73A49;">^</span><span style="color:#005CC5;">.]</span><span style="color:#D73A49;">*?</span><span style="color:#032F62;">)</span><span style="color:#D73A49;">$</span><span style="color:#032F62;">/</span><span style="color:#24292E;">, </span><span style="color:#032F62;">\`.\${</span><span style="color:#24292E;">extension</span><span style="color:#032F62;">}.$1\`</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (targetPath </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> fs.</span><span style="color:#6F42C1;">existsSync</span><span style="color:#24292E;">(targetPath)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> targetPath;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上面，没有配置参数或不是src目录下的就跳过，通过 <code>this.resolve</code> 调用其他插件完成路径解析，一般就能得到最终的路径。此时，再通过 <code>fs.existSync</code> 判断指定后缀的文件是否存在，存在就返回新路径。</p><p>很快啊，再开发环境跑没什么问题，但打包就出问题了。</p>`,8),e=[l];function t(c,r,y,i,E,d){return n(),a("div",null,e)}const A=s(o,[["render",t]]);export{u as __pageData,A as default};
