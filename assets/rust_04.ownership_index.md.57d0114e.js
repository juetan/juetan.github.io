import{_ as a,I as l,o as p,c as o,k as e,M as t,W as s}from"./chunks/framework.d6d633f0.js";const c="/assets/image-reference.661520d7.png",m=JSON.parse('{"title":"Rust系列[三]：所有权，借用和引用","description":"","frontmatter":{"title":"Rust系列[三]：所有权，借用和引用","date":"2023-08-29T13:35:00.000Z"},"headers":[],"relativePath":"rust/04.ownership/index.md","filePath":"rust/04.ownership/index.md"}'),r={name:"rust/04.ownership/index.md"},y=s(`<p>当我们声明变量时，每个变量都会被分配一片内存空间，这片内存空间要在适当的时机回收，否则会造成内存泄漏。不同的语言有不同的回收机制，部分语言手动回收，如 C 语言等；部分语言使用垃圾回收机制自动回收，如 JavaScript 等；Rust 选择的是不同路线：使用所有权机制进行半自动回收。</p><h2 id="所有权" tabindex="-1">所有权 <a class="header-anchor" href="#所有权" aria-label="Permalink to &quot;所有权&quot;">​</a></h2><p>所有权(ownership)，指的是变量值的所有权，变量值被赋值给了谁谁就拿到其所有权。通常针对的是，像字符串这样存储在堆上面的复杂类型变量，对于整数这样的简单类型变量没什么影响。</p><p>但当一个变量被赋值给另一个变量时，我们通常会说这是浅复制，但在 Rust 中称为移动所有权。</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#D73A49;">::</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> y </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#6A737D;">  // 在这里无法访问 x，这里的x是复杂类型</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">  // 在这里可以访问 a，这里的a是简单类型</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>所有权也可以跨作用域传递，如下：</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> msg </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#D73A49;">::</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">say</span><span style="color:#24292E;">(msg);</span></span>
<span class="line"><span style="color:#6A737D;">  // 这里无法访问 s</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">say</span><span style="color:#24292E;">(message</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;{}&quot;</span><span style="color:#24292E;">, message);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上面的代码中，我们创建了变量 msg, 然后传入 say 函数中。此时， msg 已将所有权移交给 message，msg 变得不再有效，而 message 则会随着 say 函数的结束而销毁。</p><h2 id="克隆" tabindex="-1">克隆 <a class="header-anchor" href="#克隆" aria-label="Permalink to &quot;克隆&quot;">​</a></h2><p>如果我们想深克隆堆上的数据，可以使用 <code>clone</code> 函数，如下：</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> s1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#D73A49;">::</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> s2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s1</span><span style="color:#D73A49;">.</span><span style="color:#6F42C1;">clone</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// false</span></span>
<span class="line"><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;s1 = {}, s2 = {}&quot;</span><span style="color:#24292E;">, s1, s2);</span></span></code></pre></div><h2 id="引用" tabindex="-1">引用 <a class="header-anchor" href="#引用" aria-label="Permalink to &quot;引用&quot;">​</a></h2><p>引用(reference)，指的是对变量的引用，包含两类：不可变引用和可变引用。不可变引用的作用是，让我们可以只给予访问权，而不移交所有权。而可变引用的作用是，让我们只给予访问权和修改权，而不移交所有权。</p><p>举个不可变引用的例子，某个函数需要需要使用参数，根据所有权规则我们传入值时也移交了这个值的所有权，而引用规则让我们可以传值时不用担心所有权。示例如下：</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> s1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#D73A49;">::</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">calculate_length</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">s1);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;The length of &#39;{}&#39; is {}.&quot;</span><span style="color:#24292E;">, s1, len);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">calculate_length</span><span style="color:#24292E;">(s</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">usize</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  s</span><span style="color:#D73A49;">.</span><span style="color:#6F42C1;">len</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>以上代码，在函数 calculate_length 的声明中，参数 s 声明为 &amp;String 类型，其中 &amp; 表示不可变引用。在调用函数时，使用 &amp;s1 传入变量 s1 的不可变引用。如果要使用可变引用，使用 &amp;mut s1 的格式，此时注意入参和实参类型要一致，示例如下：</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">mut</span><span style="color:#24292E;"> s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#D73A49;">::</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">change</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;mut</span><span style="color:#24292E;"> s);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;{s}&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">change</span><span style="color:#24292E;">(some_string</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;mut</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  some_string</span><span style="color:#D73A49;">.</span><span style="color:#6F42C1;">push_str</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;, world&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>以上，引用指向变量，变量指向变量值，关系链如下：</p>`,18),i=s(`<h2 id="借用" tabindex="-1">借用 <a class="header-anchor" href="#借用" aria-label="Permalink to &quot;借用&quot;">​</a></h2><p>借用(borrow)，暂时没找到太具体的解释，个人理解指的是套在引用上的一系列规则，目的是限制对引用的野蛮使用避免导致安全问题。有以下规则：</p><ul><li>不可变引用可同时创建多个</li><li>可变引用只能同时创建一个</li><li>同一时刻，只能存在可变引用或不可变引用；</li><li>引用与生命周期有关，引用失效后可重新创建引用；</li></ul><p>以上，前三条应该比较清晰，第四条中的生命周期是个新概念。这里的生命周期，指的是引用的生命周期，目的是确保引用在生命周期内有效，且不与其他引用冲突。举个例子如下：</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">mut</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#D73A49;">::</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> y </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">x;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> z </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;mut</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;{y}&quot;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>以上代码无法编译，因为引用 y 的生命周期范围在第 2 行到第 4 行之间(println 使用到 y)，而 z 的生命周期只有第 3 行(没有被使用)，因此在不可变引用 y 的生命周期内(范围大)，创建一个可变引用 z 是不允许的。再来看看下面这个例子</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">mut</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#D73A49;">::</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> y </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">x;</span></span>
<span class="line"><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;{y}&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> z </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;mut</span><span style="color:#24292E;"> x;</span></span></code></pre></div><p>以上代码可以编译，因为不可变引用 y 的生命周期在第 2 和第 3 行之间，而可变引用 z 的生命周期在第 4 行，两者没有冲突。</p><h2 id="切片" tabindex="-1">切片 <a class="header-anchor" href="#切片" aria-label="Permalink to &quot;切片&quot;">​</a></h2><p>切片(slice)，是一种数据类型，是对数据值的部分引用。使用切片可以访问已有变量而不用开辟新内存存放复制而来的数据，更灵活地访问部分值并确保引用安全。举个字符串的例子，看看普通写法和切片写法哪个更省内存，如下：</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello, world!&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;原字符串：{}&quot;</span><span style="color:#24292E;">, s);</span><span style="color:#6A737D;"> // 输出：Hello, world!</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子字符串：{}&quot;</span><span style="color:#24292E;">, t);</span><span style="color:#6A737D;"> // 输出：Hello</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>以上代码中，我们声明变量 s 和变量 t，其中变量 t 内容正好与 变量 s 的前 5 位相同。此时，变量 s 占据一份内存空间，而变量 t 也占据一份内存空间，且 s 和 t 存在重复的内容，这种重复是可以避免的。使用切片写法如下：</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-light"><code><span class="line"><span style="color:#D73A49;">fn</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello, world!&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> slice </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">s[</span><span style="color:#005CC5;">0</span><span style="color:#D73A49;">..</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;原字符串：{}&quot;</span><span style="color:#24292E;">, s);</span><span style="color:#6A737D;"> // 输出：Hello, world!</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">println!</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子字符串：{}&quot;</span><span style="color:#24292E;">, slice);</span><span style="color:#6A737D;"> // 输出：Hello</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>以上代码中，变量 slice 是对 s 的切片引用，最终指向的是 s 的部分内存空间，因为 slice 不存具体值因此比 t 占用的内存更小。这种引用方式，在处理大量数据时非常有帮助。</p><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h2><p>Rust 的所有权和一揽子机制，在某种程度上确保了内存安全。在 JavaScript 等高级语言中，这些概念非常陌生，但在这里你需要关注你声明的每个变量，并确保它们被安全使用。个人理解，如有错误欢迎批评指出!</p>`,16);function E(u,d,A,D,h,g){const n=l("Image");return p(),o("div",null,[y,e("p",null,[t(n,{src:c,class:"cursor-pointer"})]),i])}const F=a(r,[["render",E]]);export{m as __pageData,F as default};
